=================================================
The ``viewletManager`` and ``viewlet`` Directives
=================================================

The viewletManager directive allows you to quickly register a new content
provider that presents viewlets on a web page. You'll find more information
about viewlets and viewlet managers in the `README.txt` file.

Here is a sample directive::

  >>> from zope.app import zapi
  >>> import zope.interface
  
  >>> from zope.viewlet.tests import ILeftViewlet
  >>> from zope.configuration import xmlconfig
  >>> context = xmlconfig.string('''
  ... <configure i18n_domain="zope">
  ...   <include package="zope.viewlet" file="meta.zcml" />
  ... </configure>
  ... ''')

  >>> import os, tempfile
  >>> temp_dir = tempfile.mkdtemp()

  >>> testViewletManager = os.path.join(temp_dir, 'testviewletmanager.pt')
  >>> open(testViewletManager, 'w').write('''
  ... <div tal:repeat="viewlet options/viewlets"
  ...   <div tal:replace="viewlet"></div>
  ... </div>
  ... ''')

  >>> context = xmlconfig.string('''
  ... <configure xmlns="http://namespaces.zope.org/browser" i18n_domain="zope"
  ...            package="zope.viewlet.tests">
  ...   <viewletManager
  ...       name="testviewlet"
  ...       for="*"
  ...       providerType="zope.viewlet.tests.ILeftViewlet"
  ...       template="%s"
  ...       permission="zope.Public"
  ...       />
  ... </configure>
  ... ''' % (testViewletManager), context=context)
  
As you can see, the directive looks very similar to the page directive and you
are right. The viewlet manager directive does not permit you to specify a
`menu` and `title`, since it is not sensible to have a menu item for a viewlet.
However, it does support two more qualifying attributes, `view` and
`providerType`. While view is nearly never specified (very common default),
the `providerType` attribute *must* be specified.

# More (and more precise) information needed here...

If we now look into the adapter registry, we will find the viewlet manager:

  >>> class Content(object):
  ...     zope.interface.implements(zope.interface.Interface)
  >>> content = Content()

  >>> from zope.publisher.browser import TestRequest
  >>> request = TestRequest()

  >>> from zope.app.publisher.browser import BrowserView
  >>> view = BrowserView(content, request)

  >>> import zope.interface
  >>> from zope.viewlet.interfaces import IViewletManager
  
  >>> manager = zapi.getMultiAdapter(
  ...     (content, request, view), IViewletManager, name='testviewlet')

As we did not yet associate viewlets with this viewlet manager, calling it
gives us an empty string:

  >>> manager().strip()
  u''

So let's now create a viewlet for the viewlet manager:

  >>> testViewlet = os.path.join(temp_dir, 'testviewlet.pt')
  >>> open(testViewlet, 'w').write('''
  ... <div>testviewlet content</div>
  ... ''')
  
  >>> context = xmlconfig.string('''
  ... <configure xmlns="http://namespaces.zope.org/browser" i18n_domain="zope"
  ...            package="zope.viewlet.tests">
  ...   <viewlet
  ...       name="testviewlet"
  ...       for="*"
  ...       providerType="zope.viewlet.tests.ILeftViewlet"
  ...       template="%s"
  ...       permission="zope.Public"
  ...       />
  ... </configure>
  ... ''' % (testViewlet), context=context)

The ``viewlet`` directive is similar to the viewletManager directive.

If we look into the adapter registry, we will find the viewlet:

  >>> from zope.viewlet.interfaces import IViewlet
  
  >>> viewlet = zapi.getMultiAdapter(
  ...     (content, request, view, manager), IViewlet, name='testviewlet')
  >>> viewlet().strip()
  u'<div>testviewlet content</div>'

The manager now also gives us the output of the one and only viewlet:

  >>> manager().strip()
  u'<div>testviewlet content</div>'

Let's now ensure that we can also specify a viewlet class:

  >>> context = xmlconfig.string('''
  ... <configure xmlns="http://namespaces.zope.org/browser" i18n_domain="zope"
  ...            package="zope.viewlet.tests">
  ...   <viewlet
  ...       name="testviewlet2"
  ...       for="*"
  ...       providerType="zope.viewlet.tests.ILeftViewlet"
  ...       template="%s"
  ...       class=".TestViewlet"
  ...       permission="zope.Public"
  ...       />
  ... </configure>
  ... ''' % testViewlet, context=context)

  >>> viewlet = zope.component.getMultiAdapter(
  ...     (content, request, view, manager), name='testviewlet2')
  >>> viewlet().strip()
  u'<div>testviewlet content</div>'

#Okay, so the template-driven cases work. But just specifying a class should
#also work:
#
#  >>> context = xmlconfig.string('''
#  ... <configure xmlns="http://namespaces.zope.org/browser" i18n_domain="zope"
#  ...            package="zope.viewlet.tests">
#  ...   <viewlet
#  ...       name="testviewlet3"
#  ...       for="*"
#  ...       providerType="zope.viewlet.tests.ILeftViewlet"
#  ...       class=".tests.TestViewlet2"
#  ...       permission="zope.Public"
#  ...       />
#  ... </configure>
#  ... ''', context=context)
#
#  >>> viewlet = zope.component.getMultiAdapter(
#  ...     (content, request, view), ILeftViewlet, name='testviewlet3')
#  >>> viewlet()
#  u'called'
#
#It should also be possible to specify an alternative attribute of the class to
#be rendered upon calling the viewlet:
#
#  >>> context = xmlconfig.string('''
#  ... <configure xmlns="http://namespaces.zope.org/browser" i18n_domain="zope"
#  ...            package="zope.viewlet.tests">
#  ...   <viewlet
#  ...       name="testviewlet4"
#  ...       for="*"
#  ...       providerType="zope.viewlet.tests.ILeftViewlet"
#  ...       class=".tests.TestViewlet"
#  ...       attribute="doSomething"
#  ...       permission="zope.Public"
#  ...       />
#  ... </configure>
#  ... ''', context=context)
#
#  >>> viewlet = zope.component.getMultiAdapter(
#  ...     (content, request, view), ILeftViewlet, name='testviewlet4')
#  >>> viewlet()
#  u'something'
#
#
#Error Scenarios
#---------------
#
#Neither the class or template have been specified:
#
#  >>> context = xmlconfig.string('''
#  ... <configure xmlns="http://namespaces.zope.org/browser" i18n_domain="zope"
#  ...            package="zope.viewlet.tests">
#  ...   <viewlet
#  ...       name="testviewlet"
#  ...       providerType="zope.viewlet.tests.ILeftViewlet"
#  ...       permission="zope.Public"
#  ...       />
#  ... </configure>
#  ... ''', context=context)
#  Traceback (most recent call last):
#  ...
#  ZopeXMLConfigurationError: File "<string>", line 4.2-8.8
#      ConfigurationError: Must specify a class or template
#
#The specified attribute is not ``__call__``, but also a template has been
#specified:
#
#  >>> context = xmlconfig.string('''
#  ... <configure xmlns="http://namespaces.zope.org/browser" i18n_domain="zope"
#  ...            package="zope.viewlet.tests">
#  ...   <viewlet
#  ...       name="testviewlet"
#  ...       providerType="zope.viewlet.tests.ILeftViewlet"
#  ...       template="test_viewlet.pt"
#  ...       attribute="faux"
#  ...       permission="zope.Public"
#  ...       />
#  ... </configure>
#  ... ''', context=context)
#  Traceback (most recent call last):
#  ...
#  ZopeXMLConfigurationError: File "<string>", line 4.2-10.8
#      ConfigurationError: Attribute and template cannot be used together.
#
#Now, we are not specifying a template, but a class that does not have the
#specified attribute:
#
#  >>> context = xmlconfig.string('''
#  ... <configure xmlns="http://namespaces.zope.org/browser" i18n_domain="zope"
#  ...            package="zope.viewlet.tests">
#  ...   <viewlet
#  ...       name="testviewlet"
#  ...       providerType="zope.viewlet.tests.ILeftViewlet"
#  ...       class=".TestViewlet"
#  ...       attribute="faux"
#  ...       permission="zope.Public"
#  ...       />
#  ... </configure>
#  ... ''', context=context)
#  Traceback (most recent call last):
#  ...
#  ZopeXMLConfigurationError: File "<string>", line 4.2-10.8
#    ConfigurationError: The provided class doesn't have the specified attribute



Cleanup
-------

  >>> import shutil
  >>> shutil.rmtree(temp_dir)
